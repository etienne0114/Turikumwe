import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:turikumwe/models/story.dart';
import 'package:turikumwe/services/database_service.dart';
import 'package:turikumwe/services/storage_service.dart';

class StoryRepository {
  final DatabaseService _databaseService;
  final StorageService _storageService;

  StoryRepository({
    required DatabaseService databaseService,
    required StorageService storageService,
  })  : _databaseService = databaseService,
        _storageService = storageService;

  Future<Story> createStory({
    required int userId,
    required String title,
    required String content,
    required String category,
    List<File>? imageFiles,
  }) async {
    try {
      List<String>? imageUrls;

      // Upload images if provided
      if (imageFiles != null && imageFiles.isNotEmpty) {
        imageUrls = [];
        for (final file in imageFiles) {
          final url = await _storageService.uploadImage(file);
          if (url != null) {
            imageUrls.add(url);
          } else {
            debugPrint('Failed to upload image: ${file.path}');
            throw Exception('Failed to upload image');
          }
        }
      }

      // Create story object
      final story = Story(
        id: 0, // Will be auto-generated by database
        userId: userId,
        title: title,
        content: content,
        images: imageUrls,
        category: category,
        createdAt: DateTime.now(),
        likesCount: 0,
      );

      // Insert into database
      final id = await _databaseService.insertStory(story);
      return story.copyWith(id: id);

    } catch (e) {
      debugPrint('Error creating story: $e');
      rethrow;
    }
  }

  Future<List<Story>> getStories({String? category}) async {
    try {
      return await _databaseService.getStoriesWithUserInfo(category: category);
    } catch (e) {
      debugPrint('Error getting stories: $e');
      rethrow;
    }
  }

  Future<List<Story>> getUserStories(int userId) async {
    try {
      return await _databaseService.getStoriesByUser(userId);
    } catch (e) {
      debugPrint('Error getting user stories: $e');
      rethrow;
    }
  }

  Future<Story?> getStoryById(int id) async {
    try {
      return await _databaseService.getStoryById(id);
    } catch (e) {
      debugPrint('Error getting story by ID: $e');
      rethrow;
    }
  }

  Future<bool> likeStory(int storyId, int userId) async {
    try {
      // Check if already liked to prevent duplicate likes
      final alreadyLiked = await _databaseService.hasUserLikedStory(storyId, userId);
      if (alreadyLiked) return true;

      return await _databaseService.likeStory(storyId, userId);
    } catch (e) {
      debugPrint('Error liking story: $e');
      return false;
    }
  }

  Future<bool> unlikeStory(int storyId, int userId) async {
    try {
      return await _databaseService.unlikeStory(storyId, userId);
    } catch (e) {
      debugPrint('Error unliking story: $e');
      return false;
    }
  }

  Future<bool> deleteStory(int storyId) async {
    try {
      // First get the story to handle image cleanup
      final story = await _databaseService.getStoryById(storyId);
      if (story == null) return false;

      // Delete from database
      final success = await _databaseService.deleteStory(storyId);

      // If successful, delete associated images from storage
      if (success && story.images != null) {
        for (final imageUrl in story.images!) {
          try {
            await _storageService.deleteImage(imageUrl);
          } catch (e) {
            debugPrint('Error deleting story image: $e');
          }
        }
      }

      return success;
    } catch (e) {
      debugPrint('Error deleting story: $e');
      return false;
    }
  }

  Future<bool> hasUserLikedStory(int storyId, int userId) async {
    try {
      return await _databaseService.hasUserLikedStory(storyId, userId);
    } catch (e) {
      debugPrint('Error checking story like status: $e');
      return false;
    }
  }

  Future<int> getStoryLikeCount(int storyId) async {
    try {
      final story = await _databaseService.getStoryById(storyId);
      return story?.likesCount ?? 0;
    } catch (e) {
      debugPrint('Error getting story like count: $e');
      return 0;
    }
  }
}